// Given a string s consisting only of letters 'a' and 'b'. In a single step you can remove one palindromic subsequence from s.

// Return the minimum number of steps to make the given string empty.

// A string is a subsequence of a given string, if it is generated by deleting some characters of a given string without changing its order.

// A string is called palindrome if is one that reads the same backward as well as forward.

// 0 <= s.length <= 1000
// s only consists of letters 'a' and 'b'


var removePalindromeSub = s => {
    if(s.length<=1)return s.length
    s=s.split('')
    
    if( s.every((d,i)=>d===s[s.length-1-i]) )return 1//1 is only if my str is already a palindrome

    return 2 //remove first as and then bs
};














//But i was stupid and missed the as and bs  constraint
// So i said, I will greedily remove the LPS in each step until my string's length is zero
//But it isnt working. The greedy method doesnt work obviously. 
//returns the indexes of the LPS
let LPS = s => {
    
    let dp = [...Array(s.length)].map(d => [...Array(s.length)].map(q => -2));
    let res =new Set()

    if(s.length==0){
        return new Set()
    }
    if(s.length==1){
        return new Set([0])
    }

    for (let i = 0; i < s.length; i++) {
        dp[i][i] = 1;
    }
    for (let i = 0; i < s.length-1; i++) {
        dp[i][i+1] =1+ Number(s[i]===s[i+1]);
    }

    for (let l = 2; l < s.length; l++) {
        for (let i = 0; i < s.length - l ; i++) {
            let j = i + l;
            if (s[i] === s[j]) {
                dp[i][j] = dp[i + 1][j - 1] + 2
            } else {
                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1])
            }
        }
    }
    let rec = (i, j) => {
        if (i>j) return;
        if(i==j){
            res.add(i)
            return
        }
        if(i==j-1){
            if(dp[i][j]==1){
                res.add(i)
            }
            else{
                res.add(i,j)
            }
            return
        }
        if (dp[i][j] === dp[i + 1][j - 1]+2&&s[i]===s[j]) {
            res.add(i)
            res.add(j)

            rec(i + 1, j - 1);
        } else if (dp[i][j] === dp[i + 1][j]) {
            rec(i + 1, j);
        } else if(dp[i][j]===dp[i][j-1]){
            rec(i, j - 1);
        }
    };
    rec(0, s.length - 1);
    let z=[]
    res.forEach(d=>z.push(d))
    z.sort((a,b)=>a-b)
    console.log('LPS: ', z.map(d=>s[d])+'')
    return res;
};

var removePalindromeSub = s => {
    if(s.length<=1)return s.length
    let result=0
    s=s.split('')
    while(s.length){
        let idx=LPS(s)    
        s=s.filter((d,i)=>!idx.has(i))
        console.log(s)
        result++
    }
    return result
};

console.log(removePalindromeSub(
    "bbbbbaaababab"
   // "ababa"
// "abb"
// "baabb"
));
